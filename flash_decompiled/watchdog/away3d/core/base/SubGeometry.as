package away3d.core.base {
    import __AS3__.vec.*;
    import flash.display3D.*;
    import away3d.core.managers.*;
    import flash.geom.*;

    public class SubGeometry {

        private var _parentGeometry:Geometry;
        protected var _customData:Vector.<Number>;
        protected var _vertices:Vector.<Number>;
        protected var _uvs:Vector.<Number>;
        protected var _secondaryUvs:Vector.<Number>;
        protected var _vertexNormals:Vector.<Number>;
        protected var _vertexTangents:Vector.<Number>;
        protected var _indices:Vector.<uint>;
        protected var _indices2:Vector.<uint>;
        protected var _faceNormalsData:Vector.<Number>;
        protected var _faceWeights:Vector.<Number>;
        protected var _faceTangents:Vector.<Number>;
        protected var _vertexBuffer:Vector.<VertexBuffer3D>;
        protected var _uvBuffer:Vector.<VertexBuffer3D>;
        protected var _secondaryUvBuffer:Vector.<VertexBuffer3D>;
        protected var _vertexNormalBuffer:Vector.<VertexBuffer3D>;
        protected var _vertexTangentBuffer:Vector.<VertexBuffer3D>;
        protected var _customBuffer:Vector.<VertexBuffer3D>;
        protected var _indexBuffer:Vector.<IndexBuffer3D>;
        protected var _indexBuffer2:Vector.<IndexBuffer3D>;
        private var _autoGenerateUVs:Boolean = false;
        private var _autoDeriveVertexNormals:Boolean = true;
        private var _autoDeriveVertexTangents:Boolean = true;
        private var _useFaceWeights:Boolean = false;
        protected var _uvsDirty:Boolean = true;
        protected var _faceNormalsDirty:Boolean = true;
        protected var _faceTangentsDirty:Boolean = true;
        protected var _vertexNormalsDirty:Boolean = true;
        protected var _vertexTangentsDirty:Boolean = true;
        protected var _vertexBufferContext:Vector.<Context3D>;
        protected var _uvBufferContext:Vector.<Context3D>;
        protected var _secondaryUvBufferContext:Vector.<Context3D>;
        protected var _indexBufferContext:Vector.<Context3D>;
        protected var _indexBufferContext2:Vector.<Context3D>;
        protected var _vertexNormalBufferContext:Vector.<Context3D>;
        protected var _vertexTangentBufferContext:Vector.<Context3D>;
        protected var _customBufferContext:Vector.<Context3D>;
        protected var _numVertices:uint = 0;
        protected var _numIndices:uint = 0;
        protected var _numIndices2:uint;
        protected var _numTriangles:uint;
        protected var _numTriangles2:uint;
        private var _uvScaleV:Number = 1;
        private var _customElementsPerVertex:int;
        private var _scaleU:Number = 1;
        private var _scaleV:Number = 1;

        public function SubGeometry(){
            this._vertexBuffer = new Vector.<VertexBuffer3D>(8);
            this._uvBuffer = new Vector.<VertexBuffer3D>(8);
            this._secondaryUvBuffer = new Vector.<VertexBuffer3D>(8);
            this._vertexNormalBuffer = new Vector.<VertexBuffer3D>(8);
            this._vertexTangentBuffer = new Vector.<VertexBuffer3D>(8);
            this._indexBuffer = new Vector.<IndexBuffer3D>(8);
            this._indexBuffer2 = new Vector.<IndexBuffer3D>(8);
            this._vertexBufferContext = new Vector.<Context3D>(8);
            this._uvBufferContext = new Vector.<Context3D>(8);
            this._secondaryUvBufferContext = new Vector.<Context3D>(8);
            this._indexBufferContext = new Vector.<Context3D>(8);
            this._indexBufferContext2 = new Vector.<Context3D>(8);
            this._vertexNormalBufferContext = new Vector.<Context3D>(8);
            this._vertexTangentBufferContext = new Vector.<Context3D>(8);
            super();
        }
        public function get numVertices():uint{
            return (this._numVertices);
        }
        public function get numTriangles():uint{
            return (this._numTriangles);
        }
        public function get numTriangles2():uint{
            return (this._numTriangles2);
        }
        public function get autoGenerateDummyUVs():Boolean{
            return (this._autoGenerateUVs);
        }
        public function set autoGenerateDummyUVs(value:Boolean):void{
            this._autoGenerateUVs = value;
            this._uvsDirty = value;
        }
        public function get autoDeriveVertexNormals():Boolean{
            return (this._autoDeriveVertexNormals);
        }
        public function set autoDeriveVertexNormals(value:Boolean):void{
            this._autoDeriveVertexNormals = value;
            this._vertexNormalsDirty = value;
        }
        public function get useFaceWeights():Boolean{
            return (this._useFaceWeights);
        }
        public function set useFaceWeights(value:Boolean):void{
            this._useFaceWeights = value;
            if (this._autoDeriveVertexNormals){
                this._vertexNormalsDirty = true;
            };
            if (this._autoDeriveVertexTangents){
                this._vertexTangentsDirty = true;
            };
            this._faceNormalsDirty = true;
        }
        public function get autoDeriveVertexTangents():Boolean{
            return (this._autoDeriveVertexTangents);
        }
        public function set autoDeriveVertexTangents(value:Boolean):void{
            this._autoDeriveVertexTangents = value;
            this._vertexTangentsDirty = value;
        }
        public function initCustomBuffer(numVertices:int, elementsPerVertex:int):void{
            this._numVertices = numVertices;
            this._customElementsPerVertex = elementsPerVertex;
            this._customBuffer = new Vector.<VertexBuffer3D>(8);
            this._customBufferContext = new Vector.<Context3D>(8);
        }
        public function getCustomBuffer(stage3DProxy:Stage3DProxy):VertexBuffer3D{
            var contextIndex:int = stage3DProxy._stage3DIndex;
            var context:Context3D = stage3DProxy._context3D;
            if (((!((this._customBufferContext[contextIndex] == context))) || (!(this._customBuffer[contextIndex])))){
                this._customBuffer[contextIndex] = context.createVertexBuffer(this._numVertices, this._customElementsPerVertex);
                this._customBuffer[contextIndex].uploadFromVector(this._customData, 0, this._numVertices);
                this._customBufferContext[contextIndex] = context;
            };
            return (this._customBuffer[contextIndex]);
        }
        public function getVertexBuffer(stage3DProxy:Stage3DProxy):VertexBuffer3D{
            var contextIndex:int = stage3DProxy._stage3DIndex;
            var context:Context3D = stage3DProxy._context3D;
            if (((!((this._vertexBufferContext[contextIndex] == context))) || (!(this._vertexBuffer[contextIndex])))){
                this._vertexBuffer[contextIndex] = context.createVertexBuffer(this._numVertices, 3);
                this._vertexBuffer[contextIndex].uploadFromVector(this._vertices, 0, this._numVertices);
                this._vertexBufferContext[contextIndex] = context;
            };
            return (this._vertexBuffer[contextIndex]);
        }
        public function getUVBuffer(stage3DProxy:Stage3DProxy):VertexBuffer3D{
            var contextIndex:int = stage3DProxy._stage3DIndex;
            var context:Context3D = stage3DProxy._context3D;
            if (((this._autoGenerateUVs) && (this._uvsDirty))){
                this.updateDummyUVs();
            };
            if (((!((this._uvBufferContext[contextIndex] == context))) || (!(this._uvBuffer[contextIndex])))){
                this._uvBuffer[contextIndex] = context.createVertexBuffer(this._numVertices, 2);
                this._uvBuffer[contextIndex].uploadFromVector(this._uvs, 0, this._numVertices);
                this._uvBufferContext[contextIndex] = context;
            };
            return (this._uvBuffer[contextIndex]);
        }
        public function applyTransformation(transform:Matrix3D):void{
            var i:uint;
            var i0:uint;
            var i1:uint;
            var i2:uint;
            var len:uint = (this._vertices.length / 3);
            var v3:Vector3D = new Vector3D();
            var bakeNormals:Boolean = !((this._vertexNormals == null));
            var bakeTangents:Boolean = !((this._vertexTangents == null));
            i = 0;
            while (i < len) {
                i0 = (3 * i);
                i1 = (i0 + 1);
                i2 = (i0 + 2);
                v3.x = this._vertices[i0];
                v3.y = this._vertices[i1];
                v3.z = this._vertices[i2];
                v3 = transform.transformVector(v3);
                this._vertices[i0] = v3.x;
                this._vertices[i1] = v3.y;
                this._vertices[i2] = v3.z;
                if (bakeNormals){
                    v3.x = this._vertexNormals[i0];
                    v3.y = this._vertexNormals[i1];
                    v3.z = this._vertexNormals[i2];
                    v3 = transform.deltaTransformVector(v3);
                    this._vertexNormals[i0] = v3.x;
                    this._vertexNormals[i1] = v3.y;
                    this._vertexNormals[i2] = v3.z;
                };
                if (bakeTangents){
                    v3.x = this._vertexTangents[i0];
                    v3.y = this._vertexTangents[i1];
                    v3.z = this._vertexTangents[i2];
                    v3 = transform.deltaTransformVector(v3);
                    this._vertexTangents[i0] = v3.x;
                    this._vertexTangents[i1] = v3.y;
                    this._vertexTangents[i2] = v3.z;
                };
                i++;
            };
        }
        public function getSecondaryUVBuffer(stage3DProxy:Stage3DProxy):VertexBuffer3D{
            var contextIndex:int = stage3DProxy._stage3DIndex;
            var context:Context3D = stage3DProxy._context3D;
            if (((!((this._secondaryUvBufferContext[contextIndex] == context))) || (!(this._secondaryUvBuffer[contextIndex])))){
                this._secondaryUvBuffer[contextIndex] = context.createVertexBuffer(this._numVertices, 2);
                this._secondaryUvBuffer[contextIndex].uploadFromVector(this._secondaryUvs, 0, this._numVertices);
                this._secondaryUvBufferContext[contextIndex] = context;
            };
            return (this._secondaryUvBuffer[contextIndex]);
        }
        public function getVertexNormalBuffer(stage3DProxy:Stage3DProxy):VertexBuffer3D{
            var contextIndex:int = stage3DProxy._stage3DIndex;
            var context:Context3D = stage3DProxy._context3D;
            if (((this._autoDeriveVertexNormals) && (this._vertexNormalsDirty))){
                this.updateVertexNormals();
            };
            if (((!((this._vertexNormalBufferContext[contextIndex] == context))) || (!(this._vertexNormalBuffer[contextIndex])))){
                this._vertexNormalBuffer[contextIndex] = context.createVertexBuffer(this._numVertices, 3);
                this._vertexNormalBuffer[contextIndex].uploadFromVector(this._vertexNormals, 0, this._numVertices);
                this._vertexNormalBufferContext[contextIndex] = context;
            };
            return (this._vertexNormalBuffer[contextIndex]);
        }
        public function getVertexTangentBuffer(stage3DProxy:Stage3DProxy):VertexBuffer3D{
            var contextIndex:int = stage3DProxy._stage3DIndex;
            var context:Context3D = stage3DProxy._context3D;
            if (this._vertexTangentsDirty){
                this.updateVertexTangents();
            };
            if (((!((this._vertexTangentBufferContext[contextIndex] == context))) || (!(this._vertexTangentBuffer[contextIndex])))){
                this._vertexTangentBuffer[contextIndex] = context.createVertexBuffer(this._numVertices, 3);
                this._vertexTangentBuffer[contextIndex].uploadFromVector(this._vertexTangents, 0, this._numVertices);
                this._vertexTangentBufferContext[contextIndex] = context;
            };
            return (this._vertexTangentBuffer[contextIndex]);
        }
        public function getIndexBuffer(stage3DProxy:Stage3DProxy):IndexBuffer3D{
            var contextIndex:int = stage3DProxy._stage3DIndex;
            var context:Context3D = stage3DProxy._context3D;
            if (((!((this._indexBufferContext[contextIndex] == context))) || (!(this._indexBuffer[contextIndex])))){
                this._indexBuffer[contextIndex] = context.createIndexBuffer(this._numIndices);
                this._indexBuffer[contextIndex].uploadFromVector(this._indices, 0, this._numIndices);
                this._indexBufferContext[contextIndex] = context;
            };
            return (this._indexBuffer[contextIndex]);
        }
        public function getIndexBuffer2(stage3DProxy:Stage3DProxy):IndexBuffer3D{
            var contextIndex:int = stage3DProxy._stage3DIndex;
            var context:Context3D = stage3DProxy._context3D;
            if (((!((this._indexBufferContext2[contextIndex] == context))) || (!(this._indexBuffer2[contextIndex])))){
                this._indexBuffer2[contextIndex] = context.createIndexBuffer(this._numIndices2);
                this._indexBuffer2[contextIndex].uploadFromVector(this._indices2, 0, this._numIndices2);
                this._indexBufferContext2[contextIndex] = context;
            };
            return (this._indexBuffer2[contextIndex]);
        }
        public function clone():SubGeometry{
            var clone:SubGeometry = new SubGeometry();
            clone.updateVertexData(this._vertices.concat());
            clone.updateUVData(this._uvs.concat());
            clone.updateIndexData(this._indices.concat());
            if (this._secondaryUvs){
                clone.updateSecondaryUVData(this._secondaryUvs.concat());
            };
            if (!(this._autoDeriveVertexNormals)){
                clone.updateVertexNormalData(this._vertexNormals.concat());
            };
            if (!(this._autoDeriveVertexTangents)){
                clone.updateVertexTangentData(this._vertexTangents.concat());
            };
            return (clone);
        }
        public function scale(scale:Number):void{
            var len:uint = this._vertices.length;
            var i:uint;
            while (i < len) {
                this._vertices[i] = (this._vertices[i] * scale);
                i++;
            };
            this.invalidateBuffers(this._vertexBufferContext);
        }
        public function get scaleU():Number{
            return (this._scaleU);
        }
        public function get scaleV():Number{
            return (this._scaleV);
        }
        public function scaleUV(scaleU:Number=1, scaleV:Number=1):void{
            var i:uint;
            while (i < this._uvs.length) {
                this._uvs[i] = (this._uvs[i] / this._scaleU);
                this._uvs[i] = (this._uvs[i] * scaleU);
                i++;
                this._uvs[i] = (this._uvs[i] / this._scaleV);
                this._uvs[i] = (this._uvs[i] * scaleV);
                i++;
            };
            this._scaleU = scaleU;
            this._scaleV = scaleV;
            this.invalidateBuffers(this._uvBufferContext);
        }
        public function dispose():void{
            this.disposeAllVertexBuffers();
            this.disposeIndexBuffers(this._indexBuffer);
            this._customBuffer = null;
            this._vertexBuffer = null;
            this._vertexNormalBuffer = null;
            this._uvBuffer = null;
            this._secondaryUvBuffer = null;
            this._vertexTangentBuffer = null;
            this._indexBuffer = null;
            this._vertices = null;
            this._uvs = null;
            this._secondaryUvs = null;
            this._vertexNormals = null;
            this._vertexTangents = null;
            this._indices = null;
            this._faceNormalsData = null;
            this._faceWeights = null;
            this._faceTangents = null;
            this._customData = null;
            this._vertexBufferContext = null;
            this._uvBufferContext = null;
            this._secondaryUvBufferContext = null;
            this._indexBufferContext = null;
            this._vertexNormalBufferContext = null;
            this._vertexTangentBufferContext = null;
            this._customBufferContext = null;
        }
        protected function disposeAllVertexBuffers():void{
            this.disposeVertexBuffers(this._vertexBuffer);
            this.disposeVertexBuffers(this._vertexNormalBuffer);
            this.disposeVertexBuffers(this._uvBuffer);
            this.disposeVertexBuffers(this._secondaryUvBuffer);
            this.disposeVertexBuffers(this._vertexTangentBuffer);
            if (this._customBuffer){
                this.disposeVertexBuffers(this._customBuffer);
            };
        }
        public function get vertexData():Vector.<Number>{
            return (this._vertices);
        }
        public function updateCustomData(data:Vector.<Number>):void{
            this._customData = data;
            this.invalidateBuffers(this._customBufferContext);
        }
        public function updateVertexData(vertices:Vector.<Number>):void{
            if (this._autoDeriveVertexNormals){
                this._vertexNormalsDirty = true;
            };
            if (this._autoDeriveVertexTangents){
                this._vertexTangentsDirty = true;
            };
            this._faceNormalsDirty = true;
            this._vertices = vertices;
            var numVertices:int = (vertices.length / 3);
            if (numVertices != this._numVertices){
                this.disposeAllVertexBuffers();
            };
            this._numVertices = numVertices;
            this.invalidateBuffers(this._vertexBufferContext);
            this.invalidateBounds();
        }
        private function invalidateBounds():void{
            if (this._parentGeometry){
                this._parentGeometry.invalidateBounds(this);
            };
        }
        public function get UVData():Vector.<Number>{
            return (this._uvs);
        }
        public function get secondaryUVData():Vector.<Number>{
            return (this._secondaryUvs);
        }
        public function updateUVData(uvs:Vector.<Number>):void{
            if (this._autoDeriveVertexTangents){
                this._vertexTangentsDirty = true;
            };
            this._faceTangentsDirty = true;
            this._uvs = uvs;
            this.invalidateBuffers(this._uvBufferContext);
        }
        public function updateSecondaryUVData(uvs:Vector.<Number>):void{
            this._secondaryUvs = uvs;
            this.invalidateBuffers(this._secondaryUvBufferContext);
        }
        public function get vertexNormalData():Vector.<Number>{
            if (((this._autoDeriveVertexNormals) && (this._vertexNormalsDirty))){
                this.updateVertexNormals();
            };
            return (this._vertexNormals);
        }
        public function updateVertexNormalData(vertexNormals:Vector.<Number>):void{
            this._vertexNormalsDirty = false;
            this._autoDeriveVertexNormals = (vertexNormals == null);
            this._vertexNormals = vertexNormals;
            this.invalidateBuffers(this._vertexNormalBufferContext);
        }
        public function get vertexTangentData():Vector.<Number>{
            if (((this._autoDeriveVertexTangents) && (this._vertexTangentsDirty))){
                this.updateVertexTangents();
            };
            return (this._vertexTangents);
        }
        public function updateVertexTangentData(vertexTangents:Vector.<Number>):void{
            this._vertexTangentsDirty = false;
            this._autoDeriveVertexTangents = (vertexTangents == null);
            this._vertexTangents = vertexTangents;
            this.invalidateBuffers(this._vertexTangentBufferContext);
        }
        public function get indexData():Vector.<uint>{
            return (this._indices);
        }
        public function updateIndexData(indices:Vector.<uint>):void{
            this._indices = indices;
            this._numIndices = indices.length;
            var numTriangles:int = (this._numIndices / 3);
            if (this._numTriangles != numTriangles){
                this.disposeIndexBuffers(this._indexBuffer);
            };
            this._numTriangles = numTriangles;
            this.invalidateBuffers(this._indexBufferContext);
            this._faceNormalsDirty = true;
            if (this._autoDeriveVertexNormals){
                this._vertexNormalsDirty = true;
            };
            if (this._autoDeriveVertexTangents){
                this._vertexTangentsDirty = true;
            };
        }
        public function updateIndexData2(indices:Vector.<uint>):void{
            this._indices2 = indices;
            this._numIndices2 = this._indices2.length;
            var numTriangles2:int = (this._numIndices2 / 3);
            if (this._numTriangles2 != numTriangles2){
                this.disposeIndexBuffers(this._indexBuffer2);
            };
            this._numTriangles2 = numTriangles2;
            this.invalidateBuffers(this._indexBufferContext2);
            this._faceNormalsDirty = true;
            if (this._autoDeriveVertexNormals){
                this._vertexNormalsDirty = true;
            };
            if (this._autoDeriveVertexTangents){
                this._vertexTangentsDirty = true;
            };
        }
        function get faceNormalsData():Vector.<Number>{
            if (this._faceNormalsDirty){
                this.updateFaceNormals();
            };
            return (this._faceNormalsData);
        }
        function get parentGeometry():Geometry{
            return (this._parentGeometry);
        }
        function set parentGeometry(value:Geometry):void{
            this._parentGeometry = value;
        }
        protected function invalidateBuffers(buffers:Vector.<Context3D>):void{
            var i:int;
            while (i < 8) {
                buffers[i] = null;
                i++;
            };
        }
        protected function disposeVertexBuffers(buffers:Vector.<VertexBuffer3D>):void{
            var i:int;
            while (i < 8) {
                if (buffers[i]){
                    buffers[i].dispose();
                    buffers[i] = null;
                };
                i++;
            };
        }
        protected function disposeIndexBuffers(buffers:Vector.<IndexBuffer3D>):void{
            var i:int;
            while (i < 8) {
                if (buffers[i]){
                    buffers[i].dispose();
                    buffers[i] = null;
                };
                i++;
            };
        }
        private function updateVertexNormals():void{
            var v1:uint;
            var v2:uint;
            var v3:uint;
            var i:uint;
            var k:uint;
            var index:uint;
            var weight:uint;
            var vx:Number;
            var vy:Number;
            var vz:Number;
            var d:Number;
            if (this._faceNormalsDirty){
                this.updateFaceNormals();
            };
            var f1:uint;
            var f2:uint = 1;
            var f3:uint = 2;
            var lenV:uint = this._vertices.length;
            if (this._vertexNormals){
                while (v1 < lenV) {
                    var _temp1 = v1;
                    v1 = (v1 + 1);
                    var _local17 = _temp1;
                    this._vertexNormals[_local17] = 0;
                };
            } else {
                this._vertexNormals = new Vector.<Number>(this._vertices.length, true);
            };
            var lenI:uint = this._indices.length;
            while (i < lenI) {
                weight = ((this._useFaceWeights) ? var _temp2 = k;
k = (k + 1);
this._faceWeights[_temp2] : 1);
                var _temp3 = i;
                i = (i + 1);
                index = (this._indices[_temp3] * 3);
                var _temp4 = index;
                index = (index + 1);
                _local17 = _temp4;
                this._vertexNormals[_local17] = (this._vertexNormals[_local17] + (this._faceNormalsData[f1] * weight));
                var _temp5 = index;
                index = (index + 1);
                var _local18 = _temp5;
                this._vertexNormals[_local18] = (this._vertexNormals[_local18] + (this._faceNormalsData[f2] * weight));
                this._vertexNormals[index] = (this._vertexNormals[index] + (this._faceNormalsData[f3] * weight));
                var _temp6 = i;
                i = (i + 1);
                index = (this._indices[_temp6] * 3);
                var _temp7 = index;
                index = (index + 1);
                var _local19 = _temp7;
                this._vertexNormals[_local19] = (this._vertexNormals[_local19] + (this._faceNormalsData[f1] * weight));
                var _temp8 = index;
                index = (index + 1);
                var _local20 = _temp8;
                this._vertexNormals[_local20] = (this._vertexNormals[_local20] + (this._faceNormalsData[f2] * weight));
                this._vertexNormals[index] = (this._vertexNormals[index] + (this._faceNormalsData[f3] * weight));
                var _temp9 = i;
                i = (i + 1);
                index = (this._indices[_temp9] * 3);
                var _temp10 = index;
                index = (index + 1);
                var _local21 = _temp10;
                this._vertexNormals[_local21] = (this._vertexNormals[_local21] + (this._faceNormalsData[f1] * weight));
                var _temp11 = index;
                index = (index + 1);
                var _local22 = _temp11;
                this._vertexNormals[_local22] = (this._vertexNormals[_local22] + (this._faceNormalsData[f2] * weight));
                this._vertexNormals[index] = (this._vertexNormals[index] + (this._faceNormalsData[f3] * weight));
                f1 = (f1 + 3);
                f2 = (f2 + 3);
                f3 = (f3 + 3);
            };
            v1 = 0;
            v2 = 1;
            v3 = 2;
            while (v1 < lenV) {
                vx = this._vertexNormals[v1];
                vy = this._vertexNormals[v2];
                vz = this._vertexNormals[v3];
                d = (1 / Math.sqrt((((vx * vx) + (vy * vy)) + (vz * vz))));
                this._vertexNormals[v1] = (this._vertexNormals[v1] * d);
                this._vertexNormals[v2] = (this._vertexNormals[v2] * d);
                this._vertexNormals[v3] = (this._vertexNormals[v3] * d);
                v1 = (v1 + 3);
                v2 = (v2 + 3);
                v3 = (v3 + 3);
            };
            this._vertexNormalsDirty = false;
            this.invalidateBuffers(this._vertexNormalBufferContext);
        }
        private function updateDummyUVs():void{
            var uvs:Vector.<Number>;
            var i:uint;
            var idx:uint;
            var uvIdx:uint;
            var len:uint = ((this._vertices.length / 3) * 2);
            this._uvs = ((this._uvs) || (new Vector.<Number>()));
            this._uvs.fixed = false;
            this._uvs.length = 0;
            idx = 0;
            uvIdx = 0;
            while (idx < len) {
                if (uvIdx == 0){
                    var _temp1 = idx;
                    idx = (idx + 1);
                    var _local6 = _temp1;
                    this._uvs[_local6] = 0;
                    var _temp2 = idx;
                    idx = (idx + 1);
                    var _local7 = _temp2;
                    this._uvs[_local7] = 1;
                } else {
                    if (uvIdx == 1){
                        var _temp3 = idx;
                        idx = (idx + 1);
                        _local6 = _temp3;
                        this._uvs[_local6] = 0.5;
                        var _temp4 = idx;
                        idx = (idx + 1);
                        _local7 = _temp4;
                        this._uvs[_local7] = 0;
                    } else {
                        if (uvIdx == 2){
                            var _temp5 = idx;
                            idx = (idx + 1);
                            _local6 = _temp5;
                            this._uvs[_local6] = 1;
                            var _temp6 = idx;
                            idx = (idx + 1);
                            _local7 = _temp6;
                            this._uvs[_local7] = 1;
                        };
                    };
                };
                uvIdx++;
                if (uvIdx == 3){
                    uvIdx = 0;
                };
            };
            this._uvs.fixed = true;
            this._uvsDirty = false;
            this.invalidateBuffers(this._uvBufferContext);
        }
        private function updateVertexTangents():void{
            var v1:uint;
            var v2:uint;
            var v3:uint;
            var i:uint;
            var k:uint;
            var index:uint;
            var weight:uint;
            var vx:Number;
            var vy:Number;
            var vz:Number;
            var d:Number;
            if (this._vertexNormalsDirty){
                this.updateVertexNormals();
            };
            if (this._faceTangentsDirty){
                this.updateFaceTangents();
            };
            var f1:uint;
            var f2:uint = 1;
            var f3:uint = 2;
            var lenV:uint = this._vertices.length;
            if (this._vertexTangents){
                while (v1 < lenV) {
                    var _temp1 = v1;
                    v1 = (v1 + 1);
                    var _local17 = _temp1;
                    this._vertexTangents[_local17] = 0;
                };
            } else {
                this._vertexTangents = new Vector.<Number>(this._vertices.length, true);
            };
            var lenI:uint = this._indices.length;
            while (i < lenI) {
                weight = ((this._useFaceWeights) ? var _temp2 = k;
k = (k + 1);
this._faceWeights[_temp2] : 1);
                var _temp3 = i;
                i = (i + 1);
                index = (this._indices[_temp3] * 3);
                var _temp4 = index;
                index = (index + 1);
                _local17 = _temp4;
                this._vertexTangents[_local17] = (this._vertexTangents[_local17] + (this._faceTangents[f1] * weight));
                var _temp5 = index;
                index = (index + 1);
                var _local18 = _temp5;
                this._vertexTangents[_local18] = (this._vertexTangents[_local18] + (this._faceTangents[f2] * weight));
                this._vertexTangents[index] = (this._vertexTangents[index] + (this._faceTangents[f3] * weight));
                var _temp6 = i;
                i = (i + 1);
                index = (this._indices[_temp6] * 3);
                var _temp7 = index;
                index = (index + 1);
                var _local19 = _temp7;
                this._vertexTangents[_local19] = (this._vertexTangents[_local19] + (this._faceTangents[f1] * weight));
                var _temp8 = index;
                index = (index + 1);
                var _local20 = _temp8;
                this._vertexTangents[_local20] = (this._vertexTangents[_local20] + (this._faceTangents[f2] * weight));
                this._vertexTangents[index] = (this._vertexTangents[index] + (this._faceTangents[f3] * weight));
                var _temp9 = i;
                i = (i + 1);
                index = (this._indices[_temp9] * 3);
                var _temp10 = index;
                index = (index + 1);
                var _local21 = _temp10;
                this._vertexTangents[_local21] = (this._vertexTangents[_local21] + (this._faceTangents[f1] * weight));
                var _temp11 = index;
                index = (index + 1);
                var _local22 = _temp11;
                this._vertexTangents[_local22] = (this._vertexTangents[_local22] + (this._faceTangents[f2] * weight));
                this._vertexTangents[index] = (this._vertexTangents[index] + (this._faceTangents[f3] * weight));
                f1 = (f1 + 3);
                f2 = (f2 + 3);
                f3 = (f3 + 3);
            };
            v1 = 0;
            v2 = 1;
            v3 = 2;
            while (v1 < lenV) {
                vx = this._vertexTangents[v1];
                vy = this._vertexTangents[v2];
                vz = this._vertexTangents[v3];
                d = (1 / Math.sqrt((((vx * vx) + (vy * vy)) + (vz * vz))));
                this._vertexTangents[v1] = (this._vertexTangents[v1] * d);
                this._vertexTangents[v2] = (this._vertexTangents[v2] * d);
                this._vertexTangents[v3] = (this._vertexTangents[v3] * d);
                v1 = (v1 + 3);
                v2 = (v2 + 3);
                v3 = (v3 + 3);
            };
            this._vertexTangentsDirty = false;
            this.invalidateBuffers(this._vertexTangentBufferContext);
        }
        private function updateFaceNormals():void{
            var i:uint;
            var j:uint;
            var k:uint;
            var index:uint;
            var x1:Number;
            var x2:Number;
            var x3:Number;
            var y1:Number;
            var y2:Number;
            var y3:Number;
            var z1:Number;
            var z2:Number;
            var z3:Number;
            var dx1:Number;
            var dy1:Number;
            var dz1:Number;
            var dx2:Number;
            var dy2:Number;
            var dz2:Number;
            var cx:Number;
            var cy:Number;
            var cz:Number;
            var d:Number;
            var w:Number;
            var len:uint = this._indices.length;
            this._faceNormalsData = ((this._faceNormalsData) || (new Vector.<Number>(len, true)));
            if (this._useFaceWeights){
                this._faceWeights = ((this._faceWeights) || (new Vector.<Number>((len / 3), true)));
            };
            while (i < len) {
                var _temp1 = i;
                i = (i + 1);
                index = (this._indices[_temp1] * 3);
                var _temp2 = index;
                index = (index + 1);
                x1 = this._vertices[_temp2];
                var _temp3 = index;
                index = (index + 1);
                y1 = this._vertices[_temp3];
                z1 = this._vertices[index];
                var _temp4 = i;
                i = (i + 1);
                index = (this._indices[_temp4] * 3);
                var _temp5 = index;
                index = (index + 1);
                x2 = this._vertices[_temp5];
                var _temp6 = index;
                index = (index + 1);
                y2 = this._vertices[_temp6];
                z2 = this._vertices[index];
                var _temp7 = i;
                i = (i + 1);
                index = (this._indices[_temp7] * 3);
                var _temp8 = index;
                index = (index + 1);
                x3 = this._vertices[_temp8];
                var _temp9 = index;
                index = (index + 1);
                y3 = this._vertices[_temp9];
                z3 = this._vertices[index];
                dx1 = (x3 - x1);
                dy1 = (y3 - y1);
                dz1 = (z3 - z1);
                dx2 = (x2 - x1);
                dy2 = (y2 - y1);
                dz2 = (z2 - z1);
                cx = ((dz1 * dy2) - (dy1 * dz2));
                cy = ((dx1 * dz2) - (dz1 * dx2));
                cz = ((dy1 * dx2) - (dx1 * dy2));
                d = Math.sqrt((((cx * cx) + (cy * cy)) + (cz * cz)));
                if (this._useFaceWeights){
                    w = (d * 10000);
                    if (w < 1){
                        w = 1;
                    };
                    var _temp10 = k;
                    k = (k + 1);
                    var _local26 = _temp10;
                    this._faceWeights[_local26] = w;
                };
                d = (1 / d);
                var _temp11 = j;
                j = (j + 1);
                _local26 = _temp11;
                this._faceNormalsData[_local26] = (cx * d);
                var _temp12 = j;
                j = (j + 1);
                var _local27 = _temp12;
                this._faceNormalsData[_local27] = (cy * d);
                var _temp13 = j;
                j = (j + 1);
                var _local28 = _temp13;
                this._faceNormalsData[_local28] = (cz * d);
            };
            this._faceNormalsDirty = false;
            this._faceTangentsDirty = true;
        }
        private function updateFaceTangents():void{
            var i:uint;
            var j:uint;
            var index1:uint;
            var index2:uint;
            var index3:uint;
            var ui:uint;
            var vi:uint;
            var v0:Number;
            var dv1:Number;
            var dv2:Number;
            var denom:Number;
            var x0:Number;
            var y0:Number;
            var z0:Number;
            var dx1:Number;
            var dy1:Number;
            var dz1:Number;
            var dx2:Number;
            var dy2:Number;
            var dz2:Number;
            var cx:Number;
            var cy:Number;
            var cz:Number;
            var len:uint = this._indices.length;
            var invScale:Number = (1 / this._uvScaleV);
            this._faceTangents = ((this._faceTangents) || (new Vector.<Number>(this._indices.length, true)));
            while (i < len) {
                var _temp1 = i;
                i = (i + 1);
                index1 = this._indices[_temp1];
                var _temp2 = i;
                i = (i + 1);
                index2 = this._indices[_temp2];
                var _temp3 = i;
                i = (i + 1);
                index3 = this._indices[_temp3];
                v0 = this._uvs[uint(((index1 << 1) + 1))];
                ui = (index2 << 1);
                dv1 = ((this._uvs[uint(((index2 << 1) + 1))] - v0) * invScale);
                ui = (index3 << 1);
                dv2 = ((this._uvs[uint(((index3 << 1) + 1))] - v0) * invScale);
                vi = (index1 * 3);
                x0 = this._vertices[vi];
                y0 = this._vertices[uint((vi + 1))];
                z0 = this._vertices[uint((vi + 2))];
                vi = (index2 * 3);
                dx1 = (this._vertices[uint(vi)] - x0);
                dy1 = (this._vertices[uint((vi + 1))] - y0);
                dz1 = (this._vertices[uint((vi + 2))] - z0);
                vi = (index3 * 3);
                dx2 = (this._vertices[uint(vi)] - x0);
                dy2 = (this._vertices[uint((vi + 1))] - y0);
                dz2 = (this._vertices[uint((vi + 2))] - z0);
                cx = ((dv2 * dx1) - (dv1 * dx2));
                cy = ((dv2 * dy1) - (dv1 * dy2));
                cz = ((dv2 * dz1) - (dv1 * dz2));
                denom = (1 / Math.sqrt((((cx * cx) + (cy * cy)) + (cz * cz))));
                var _temp4 = j;
                j = (j + 1);
                var _local26 = _temp4;
                this._faceTangents[_local26] = (denom * cx);
                var _temp5 = j;
                j = (j + 1);
                var _local27 = _temp5;
                this._faceTangents[_local27] = (denom * cy);
                var _temp6 = j;
                j = (j + 1);
                var _local28 = _temp6;
                this._faceTangents[_local28] = (denom * cz);
            };
            this._faceTangentsDirty = false;
        }
        protected function disposeForStage3D(stage3DProxy:Stage3DProxy):void{
            var index:int = stage3DProxy._stage3DIndex;
            if (this._vertexBuffer[index]){
                this._vertexBuffer[index].dispose();
                this._vertexBuffer[index] = null;
            };
            if (this._uvBuffer[index]){
                this._uvBuffer[index].dispose();
                this._uvBuffer[index] = null;
            };
            if (this._secondaryUvBuffer[index]){
                this._secondaryUvBuffer[index].dispose();
                this._secondaryUvBuffer[index] = null;
            };
            if (this._vertexNormalBuffer[index]){
                this._vertexNormalBuffer[index].dispose();
                this._vertexNormalBuffer[index] = null;
            };
            if (this._vertexTangentBuffer[index]){
                this._vertexTangentBuffer[index].dispose();
                this._vertexTangentBuffer[index] = null;
            };
            if (this._indexBuffer[index]){
                this._indexBuffer[index].dispose();
                this._indexBuffer[index] = null;
            };
        }
        public function get vertexBufferOffset():int{
            return (0);
        }
        public function get normalBufferOffset():int{
            return (0);
        }
        public function get tangentBufferOffset():int{
            return (0);
        }
        public function get UVBufferOffset():int{
            return (0);
        }
        public function get secondaryUVBufferOffset():int{
            return (0);
        }

    }
}//package away3d.core.base 
